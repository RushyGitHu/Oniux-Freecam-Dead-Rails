--[[
Original script protected with MoonSec V3
Deobfuscated version with restored structure
]]

-- Initialize environment
local env = getfenv and getfenv() or _ENV
local string = string
local table = table
local math = math
local bit = bit or bit32 or require("bit")

-- VM state
local vmState = {
    constants = {},
    functions = {},
    upvalues = {},
    protos = {},
    stack = {},
    pc = 1,
    env = env
}

-- Helper functions
local function decodeString(str)
    if type(str) ~= "string" then return str end
    local result = ""
    local i = 1
    while i <= #str do
        local byte = string.byte(str, i)
        -- XOR decryption with dynamic key
        result = result .. string.char(bit.bxor(byte, vmState.key or 0))
        i = i + 1
    end
    return result
end

local function decodeNumber(n)
    if type(n) ~= "number" then return n end
    -- Reverse number encoding
    return bit.bxor(n, vmState.numKey or 0)
end

local function getConstant(chunk, idx)
    local constant = chunk.k[idx]
    if type(constant) == "string" then
        return decodeString(constant)
    elseif type(constant) == "number" then
        return decodeNumber(constant)
    end
    return constant
end

-- Main VM implementation
local function executeVM(chunk, env, ...)
    local stack = {}
    local top = -1
    local pc = 1
    local vararg = {...}
    
    -- Initialize registers
    for i = 1, chunk.maxstack do
        stack[i] = nil
    end
    
    while true do
        local inst = chunk[pc]
        pc = pc + 1
        
        -- Instruction decoding and execution
        local op = inst.op
        local a = inst.a
        local b = inst.b
        local c = inst.c
        
        if op == "GETGLOBAL" then
            stack[a] = env[getConstant(chunk, b)]
            
        elseif op == "SETGLOBAL" then
            env[getConstant(chunk, b)] = stack[a]
            
        elseif op == "LOADK" then
            stack[a] = getConstant(chunk, b)
            
        elseif op == "LOADBOOL" then
            stack[a] = b ~= 0
            if c ~= 0 then pc = pc + 1 end
            
        elseif op == "LOADNIL" then
            for i = a, b do
                stack[i] = nil
            end
            
        elseif op == "GETUPVAL" then
            stack[a] = chunk.upvals[b]
            
        elseif op == "SETUPVAL" then
            chunk.upvals[b] = stack[a]
            
        elseif op == "CALL" then
            local func = stack[a]
            local nparams = b - 1
            local nresults = c - 1
            
            local args = {}
            if nparams > 0 then
                for i = 1, nparams do
                    args[i] = stack[a + i]
                end
            elseif nparams == 0 then
                local vlen = top - a
                if vlen >= 0 then
                    for i = 1, vlen do
                        args[i] = stack[a + i]
                    end
                end
            end
            
            local results = {func(unpack(args, 1, nparams))}
            
            if nresults ~= 0 then
                for i = 1, nresults do
                    stack[a + i - 1] = results[i]
                end
                top = a + nresults - 1
            end
            
        elseif op == "RETURN" then
            if b == 0 then
                return unpack(stack, a, top)
            else
                return unpack(stack, a, a + b - 2)
            end
            
        elseif op == "CLOSURE" then
            local proto = chunk.p[b]
            local closure = {
                code = proto.code,
                constants = proto.k,
                upvals = {},
                env = env
            }
            stack[a] = closure
            
        elseif op == "ADD" then
            stack[a] = stack[b] + stack[c]
            
        elseif op == "SUB" then
            stack[a] = stack[b] - stack[c]
            
        elseif op == "MUL" then
            stack[a] = stack[b] * stack[c]
            
        elseif op == "DIV" then
            stack[a] = stack[b] / stack[c]
            
        elseif op == "POW" then
            stack[a] = stack[b] ^ stack[c]
            
        elseif op == "JMP" then
            pc = pc + b
        end
    end
end

-- Entry point
return function(...)
    -- Initialize VM state
    local chunk = vmState.protos[1]
    vmState.key = 0x1337  -- Example key, should be determined from obfuscated script
    vmState.numKey = 0x7331  -- Example number key
    return executeVM(chunk, env, ...)
end
